<?xml version="1.0"?>
<?rfc symrefs="yes"?>
<rfc ipr="trust200902" docName="certificate-transparency-draft">
  <front>
    <title>Certificate Transparency</title>
    <author initials="B" surname="Laurie" fullname="Ben Laurie"></author>
    <author initials="A" surname="Langley" fullname="Adam Langley"></author>
    <author initials="E" surname="Kasper" fullname="Emilia Kasper"></author>
    <date year='2012'></date>
  </front>
  <middle>
<section title="Design">
<t>
The aim of Certificate Transparency is to have every issued public end-entity TLS certificate recorded in one or more certificate logs. In order to detect mis-issuance of certificates, all logs are public. In particular, domain owners will be able to monitor logs for certificates issued on their own domain.
</t>
<t>
In order to protect clients from unlogged certificates, logs provide audit proofs of all recorded certificates, and clients can choose not to trust certificates that are not accompanied by an appropriate audit proof. Audit proofs are embedded in the TLS handshake to for privacy and performance reasons.
</t>
<t>
In order to ensure the correct behaviour of logs, logs also provide a global audit proof over the entire log. Any misbehaviour of logs can be detected through cross-checks on the global audit proof.
</t>
<t>
Logs are only expected to certify that they have seen a certificate and thus, we do not specify any revocation mechanism for audit proofs in this document. Logs will be append-only, and audit proofs will be valid indefinitely. 
</t>
</section>
    <section title="Cryptographic components">
      <section title="Merkle Hash Trees">
	<t>
	  Logs use binary Merkle hash trees for efficient audit proofs. The hashing algorithm is SHA-256. The input to the Merkle tree hash is a list of data entries; these entries will be hashed to form the leaves of the Merkle hash tree. The output is a single 32-byte root hash. Given an ordered list of n inputs, D[0:n] = {d(0), d(1), ..., d(n-1)}, the Merkle Tree Hash (MTH) is thus defined as follows:
	</t>
	<t>
	  The hash of an empty list is the hash of an empty string:
	  <vspace blankLines='1' />
	  MTH({}) = SHA-256().
	  <vspace blankLines='1' />
	  The hash of a list with one entry is:
	  <vspace blankLines='1' />
	  MTH({d(0)}) = SHA-256(0 || d(0)).
	  <vspace blankLines='1' />
	  For n &gt; 1, let k be the largest power of two smaller than n. The Merkle Tree Hash of an n-element list D[0:n] is then defined recursively as
	  <vspace blankLines='1' />
	  MTH(D[0:n]) = SHA-256(1 || MTH(D[0:k]) || MTH(D[k:n])),
	  <vspace blankLines='1' />
	  where || is concatenation and D[k1:k2] denotes the length (k2 - k1) list {d(k1), d(k1+1),..., d(k2-1)}.
	</t>
<t>
Note that we do not require the length of the input list to be a power of two. The resulting Merkle tree may thus not be balanced, however, its shape is uniquely determined by the number of leaves. <spanx style="emph">This Merkle tree is essentially the same as the</spanx> <eref target='http://tamperevident.cs.rice.edu/Logging.html/'>history tree</eref> <spanx style="emph">proposal except our current definition omits dummy leaves.</spanx>
</t>
      <section title="Merkle audit paths" anchor='merkle_paths'>
	<t>
	  A Merkle audit path for a leaf in a Merkle hash tree is the list of all additional nodes in the Merkle tree required to compute the Merkle Tree Hash for that tree. If the root computed from the audit path matches the true root, then the audit path is proof that the leaf exists in the tree.
	</t>
	<t> Given an ordered list of n inputs to the tree, D[0:n] = {d(0), ..., d(n-1)}, the Merkle audit path PATH(m, D[0:n]) for the (m+1)th input d(m), 0 &lt;= m &lt; n, is defined as follows:
	</t>
	<t>
	  The path for the single leaf in a tree with a one-element input list D[0:1] = {d(0)} is empty:
	  <vspace blankLines='1' />
	  PATH(0, {d(0)}) = {}
	  <vspace blankLines='1' />
	  For n &gt; 1, let k be the largest power of two smaller than n. The path for the (m+1)th element d(m) in a list of n &gt m elements is then defined recursively as
	  <vspace blankLines='1' />
	  PATH(m, D[0:n]) = PATH(m, D[0:k]) : MTH(D[k:n]) for m &lt; k; and
	  <vspace blankLines='1' />
	  PATH(m, D[0:n]) = PATH(m - k, D[k:n]) : MTH(D[0:k]) for k &lt;= m &lt; n,
	  <vspace blankLines='1' />
	  where : is concatenation of lists and D[k1:k2] denotes the length (k2 - k1) list {d(k1), d(k1+1),..., d(k2-1)} as before.
	</t>
      </section>

      <section title="Merkle consistency proofs" anchor='consistency'>
	<t>
	  Merkle consistency proofs prove the append-only property of the tree. A Merkle consistency proof for a Merkle Tree Hash MTH(D[0:n]) and a previously advertised hash MTH(D[0:m]) of the first m leaves, m &lt;= n, is the list of nodes in the Merkle tree required to verify that the first m inputs D[0:m] are equal in both trees. Thus, a consistency proof must contain a set of intermediate nodes (i.e., commitments to inputs) sufficient to verify MTH(D[0:n]), such that (a subset of) the same nodes can be used to verify MTH(D[0:m]). We define an algorithm that outputs the (unique) minimal consistency proof. 
	</t>
	<t> Given an ordered list of n inputs to the tree, D[0:n] = {d(0), ..., d(n-1)}, the Merkle consistency proof PROOF(m, D[0:n]) for a previous root hash MTH(D[0:m]), 0 &lt; m &lt; n, is defined as PROOF(m, D[0:n]) = SUBPROOF(m, D[0:n], true):
	</t>
	<t>
	  The subproof for m = n is empty if m is the value for which PROOF was originally requested (meaning that the subtree root hash MTH(D[0:m]) is known):
	  <vspace blankLines='1' />
	  SUBPROOF(m, D[0:m], true) = {}
	  <vspace blankLines='1' />
 	  The subproof for m = n is the root hash committing inputs D[0:m] otherwise:
	  <vspace blankLines='1' />
	  SUBPROOF(m, D[0:m], false) = {MTH(D[0:m])}
	  <vspace blankLines='1' />    
	  For m &lt n, let k be the largest power of two smaller than n. The subproof is then defined recursively.
	  <vspace blankLines='1' />
If m &lt;= k, the right subtree entries D[k:n] only exist in the current tree. We prove that the left subtree entries D[0:k] are consistent and add a commitment to D[k:n]:
	  <vspace blankLines='1' />
	  SUBPROOF(m, D[0:n], b) = SUBPROOF(m, D[0:k], b) : MTH(D[k:n]).
	  <vspace blankLines='1' />
If m > k, the left subtree entries D[0:k] are identical in both trees. We prove that the right subtree entries D[k:n] are consistent and add a commitment to D[0:k].
	  <vspace blankLines='1' />
	  SUBPROOF(m, D[0:n], b) = SUBPROOF(m - k, D[k:n], false) : MTH(D[0:k]).
	  <vspace blankLines='1' />
	  Here : is concatenation of lists and D[k1:k2] denotes the length (k2 - k1) list {d(k1), d(k1+1),..., d(k2-1)} as before.
	</t>
	<t>
	  The number of nodes in the resulting proof is bounded above by ceil(log2(n)) + 1.
	</t>
      </section>

	<section title="Example">
	  <t>
	    The binary Merkle tree with 7 leaves:
<figure>
<artwork>    
            hash
           /    \
          /      \
         /        \
        /          \
       /            \
      k              l
     / \            / \
    /   \          /   \ 
   /     \        /     \    
  g       h      i      j
 / \     / \    / \     |
 a b     c d    e f     d6       
 | |     | |    | |                               
d0 d1   d2 d3  d4 d5    
</artwork>
</figure>
	  </t>
	  <t>
	    The audit path for d0 is [b, h, l].
	  </t>
	  <t>
	    The audit path for d3 is [c, g, l].
	  </t>
	  <t>
	    The audit path for d4 is [f, j, k].
	  </t>
	  <t>
	    The audit path for d6 is [i, k].
	  </t>
	  <t>
	    The same tree, built incrementally in four steps:
<figure>
<artwork>    
    hash0          hash1=k 
    / \              /  \  
   /   \            /    \ 
  /     \          /      \ 
  g      c         g       h 
 / \     |        / \     / \ 
 a b     d2       a b     c d 
 | |              | |     | |                   
d0 d1            d0 d1   d2 d3

          hash2                    hash
          /  \                    /    \
         /    \                  /      \
        /      \                /        \
       /        \              /          \
      /          \            /            \
     k            i          k              l
    / \          / \        / \            / \
   /   \         e f       /   \          /   \
  /     \        | |      /     \        /     \    
 g       h      d4 d5    g       h      i      j
/ \     / \             / \     / \    / \     |
a b     c d             a b     c d    e f     d6       
| |     | |             | |     | |    | |                               
d0 d1   d2 d3           d0 d1   d2 d3  d4 d5    
</artwork>
</figure>
	  </t>
	  <t>
	    The consistency proof between hash0 and hash is PROOF(3, D[0:7]) = [c, d, g, l]. c, g are used to verify hash0, and d, l are additionally used to verify hash.
	  </t>
	  <t>
	    The consistency proof between hash1 and hash is PROOF(4, D[0:7]) = [l]. hash can be verified, using hash1=k and l.
	  </t>
	  <t>
	    The consistency proof between hash2 and hash is PROOF(6, D[0:7]) = [i, j, k]. k, i are used to verify hash1, and j is additionally used to verify hash.
	  </t>
	</section>
      </section>
    </section>
      <section title="Log Format">
	<section title="Log Entries">
	  <t>
	    Certificate owners may submit each leaf certificate to certificate logs for public auditing. Each submitted certificate must be accompanied by all additional certificates required to verify the certificate. The root certificate may be omitted.
	  </t>
	  <t>
	    Logs may verify the leaf certificate, using their set of trusted roots. Logs shall periodically publish received certificates. Logs may refuse to publish certificates they cannot validate.
	  </t>
	  <t>
	    Each certificate entry in the log MUST include the following components:
	  </t>
	  <figure>
	    <artwork>
enum { x509_chain_entry(0), (65535) } LogEntryType;

struct {
    LogEntryType type;
    select (type) {
    case x509_chain_entry: X509ChainEntry;
    } entry;
} LogEntry;

struct {
    Certificate leaf_certificate;
    Certificate certificate_chain&lt;0..2^24-1&gt;;
} X509ChainEntry;
	    </artwork>
	  </figure>
	  <t>[benl: Should we consider a small number for the certificate_chain? Or perhaps note that a log can impose a limit?]
	  </t>
	  <t>
	    <spanx style="verb">leaf_certificate</spanx> is the end-entity certificate submitted for auditing.
	  </t>
	  <t>
	    <spanx style="verb">certificate_list</spanx> is the collection of additional certificates required to verify the leaf certificate. This collection MUST be ordered by the content of each certificate, read first byte first, in ascending order. [agl: why aren't we requiring them to be in verification order? It would make the logs simplier which is a good thing.]
	  </t>
	</section>
	<section title="Log Segments">
	  <t> A certificate log MUST periodically publish all new log entries as a log segment. The log MUST sign these entries by constructing a binary Log Segment Merkle Hash Tree with log entries as consecutive inputs to the tree, and signing the root of that tree. The hashing algorithm is SHA-256. The signature algorithm is ECDSA with the curve NIST P-256.
	  </t>
	  <t>
	   Log segments MUST have an incrementing sequence number and the increment MUST be one. At every update, logs MUST sign a secondary Segment Info Merkle Hash Tree of all log segment signatures issued so far, ordered in the tree according to the sequence number.
</t>
	  <t>
	    Structure of the signature:
	  </t>
	  <figure>
	    <artwork>
enum { LogSegment, SegmentInfo } TreeType;
	    </artwork>
	  </figure>
	  <figure>
	    <artwork>
digitally-signed struct {
    TreeType tree_type;
    uint32 tree_size;
    uint32 sequence_number;
    opaque root_hash[32];
} MerkleTreeSignature;
	    </artwork>
	  </figure>
	  <t>
	    <spanx style="verb">tree_type</spanx> is the type of the Merkle tree (either a Log Segment tree, or a Segment Info tree).
	  </t>
	  <t>
	    <spanx style="verb">tree_size</spanx> is the number of leaves in the tree.
	  </t>
	  <t>
	    <spanx style="verb">sequence_number</spanx> is the number of the current segment. In the case of a <spanx style="verb">SegmentInfo</spanx> signature, the <spanx style="verb">sequence_number</spanx> MUST equal the <spanx style="verb">tree_size</spanx>.
	  </t>
	  <t>
	    <spanx style="verb">root_hash</spanx> is the root of the Merkle Hash Tree.
	  </t>
<t>
For every segment, logs MUST publish all the log entries corresponding to that segment, as well as a segment info record containing the signatures on the Log Segment Merkle Hash Tree and the current Segment Info Merkle Hash Tree.
</t>
<t>
Structure of the segment info record:
</t>
<figure>
  <artwork>
struct {
    uint32 timestamp;
    MerkleTreeSignature signed_log_segment_tree;
    MerkleTreeSignature signed_segment_info_tree;
} SegmentInfo;
  </artwork>
</figure>
<t>
<spanx style="verb">signed_log_segment_tree</spanx> is the signature on the Log Segment Merkle Hash Tree.
</t>
	  <t>
	    <spanx style="verb">signed_segment_info_tree</spanx> is the signature on the current Segment Info Merkle Hash Tree. The <spanx style="verb">sequence_number</spanx> in the <spanx style="verb">signed_log_segment_tree</spanx> MUST match the <spanx style="verb">sequence_number</spanx> in the <spanx style="verb">signed_segment_info_tree</spanx>.
	  </t> 
	</section>
	<section title="Audit Proofs">
	  <t> It is possible to audit the entire log by computing the <spanx style="verb">root_hash</spanx> values corresponding to individual segment trees, reconstructing the current Segment Info Merkle Hash Tree and verifying the <spanx style="verb">signed_segment_info_tree</spanx> signature. We rely on cross-checks of this signature between auditors to verify that their views of the log are consistent.
	  </t>
	  <t>
	    Additionally, logs provide two types of audit proofs for partial checks.
	  </t>
	  <t>
	    Logs MUST provide servers with an audit proof for each logged certificate. Servers may present audit proofs from one or more logs to the client together with the certificate. Clients may reject certificates that do not have a desired number of valid audit proofs. [ben: can anyone request these proofs? don't see why not]
	  </t>
<t>
Logs MUST also provide audit proofs for the Segment Info Merkle Hash Tree. Clients may request such audit proofs for a segment to verify that the segment appears in the global log.
</t>
	  <t>
	    Structure of the audit proof:
	  </t>
	  <figure>
	    <artwork>
struct {
    opaque hash[32];
} MerkleNode;
	    </artwork>
	  </figure>
	  <figure>
	    <artwork>
struct {
    uint32 leaf_index;
    MerkleNode audit_path&lt;0..2^16-1&gt;;
    MerkleTreeSignature signed_tree;
} AuditProof;
	    </artwork>
	  </figure>
	  <t>
	    <spanx style="verb">leaf_index</spanx> is the index of the audited node in the Merkle tree, from 0 to <spanx style="verb">tree_size - 1</spanx>.
	  </t>
	  <t>
	    <spanx style="verb">audit_path</spanx> is a list of additional nodes in the Merkle tree required for reconstructing the root hash. Nodes must be listed from leaf to root level, i.e., in the order they are used in the Merkle Tree Hash computation, as defined in <xref target='merkle_paths' />. <spanx style="emph">Notice that the left-right ordering is determined by the position of the leaf.</spanx> The leaf node under audit as well as the root node shall be omitted from the path.
	  </t>
	  <t>
	    <spanx style="verb">signed_tree</spanx> is the signature on the tree.
	  </t>
	  <t>
	    Servers who send an audit proof for a certificate must also serve all intermediate certificates recorded in the  <spanx style="verb">certificate_list</spanx> of the <spanx style="verb">X509ChainEntry</spanx>. Clients who verify the certificate audit proof use these certificates to reconstruct the leaf node of the Log Segment Merkle Hash Tree. A valid audit proof MUST satisfy the following:
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>
		The <spanx style="verb">leaf_index</spanx> MUST be greater than 0 and MUST NOT exceed <spanx style="verb">tree_size</spanx> in <spanx style="verb">signed_tree</spanx>;
	      </t>
	      <t>
		The root hash reconstructed from the leaf and the <spanx style="verb">audit_path</spanx> MUST equal the <spanx style="verb">root_hash</spanx> of <spanx style="verb">signed_tree</spanx>;
	      </t>
	      <t>
		The signature on <spanx style="verb">signed_tree</spanx> MUST be a valid log signature;
	      </t>
	      <t>
		The <spanx style="verb">tree_type</spanx> of <spanx style="verb">signed_tree</spanx> MUST be <spanx style="verb">LogSegment</spanx> for certificate audit proofs, and MUST be <spanx style="verb">SegmentInfo</spanx> for a Segment Info audit proof.
	      </t>
	    </list>
	  </t>
	  <t>
	    Clients may construct a different certificate chain than the one recorded in the <spanx style="verb">X509ChainEntry</spanx> to verify the validity of the leaf certificate. Clients who do so must additionally check that the public key sequence of the constructed chain matches the public key sequence in the <spanx style="verb">LogEntry</spanx> <spanx style="verb">certificate_list</spanx>, with only two exceptions [agl: here we're talking about sequences of public keys, but we ordered the certificates by contents, destroying the sequence]:
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>
		The public keys in the constructed chain may form a subsequence of the public keys in the <spanx style="verb">certificate_list</spanx>. In this case, the root public key in the constructed chain must be present in the <spanx style="verb">certificate_list</spanx>.
	      </t>
	      <t>
		The constructed chain may contain additional public keys after the keys in the <spanx style="verb">certificate_list</spanx>. In this case, the first extra certificate in the chain must directly certify the top public key in the  <spanx style="verb">certificate_list</spanx>.
	      </t>
	    </list>
	  </t>
	</section>
      </section>
      <section title="Efficiency Considerations">
	<t>
	  The two-tier Merkle proof design serves the purpose of keeping communication overhead low. <spanx style="emph">Logs should choose an appropriate refresh rate. The log refresh period should be short enough to keep certificate issuance latency low and certificate audit proofs small. At the same time, it should be long enough to make integrity cross-checks efficient (clients should not have to query and compare segment audit proofs for new segments too often).</spanx>
	</t>
	<t>
	  Auditing the log for integrity does not require third parties to maintain a copy of the entire log. The Segment Info Merkle Hash Tree root hash can be updated incrementally as new segments become available, without recomputing the entire tree. Third party auditors need only store a logarithmic number of intermediate nodes in the Segment Info Merkle Hash Tree.
	</t>
	<t>
	 Additionally, the Merkle consistency proofs defined in <xref target='consistency' /> can be used to efficiently prove the append-only property of an incremental update to the Segment Info Merkle Hash Tree, without auditing the entire tree. [ekasper: are logs required to provide these proofs?]
	</t>
      </section>
  </middle>
  <back>
  </back>
</rfc>
