<?xml version="1.0"?>
<?rfc symrefs="yes"?>
<rfc ipr="trust200902" docName="certificate-transparency-draft">
  <front>
    <title>Certificate Transparency</title>
    <author initials="B" surname="Laurie" fullname="Ben Laurie"></author>
    <author initials="A" surname="Langley" fullname="Adam Langley"></author>
    <author initials="E" surname="Kasper" fullname="Emilia Kasper"></author>
    <date year='2012'></date>
  </front>
  <middle>
<section title="Design">
<t>
The aim of Certificate Transparency is to have every public end-entity TLS certificate issued by a known Certficate Authority recorded in one or more certificate logs. In order to detect mis-issuance of certificates, all logs are publicly verifiable. In particular, domain owners will be able to monitor logs for certificates issued on their own domain.
</t>
<t>
In order to protect clients from unlogged certificates, logs sign all recorded certificates, and clients can choose not to trust certificates that are not accompanied by an appropriate signature. For privacy and performance reasons log signatures are embedded in the TLS handshake via the TLS authorization extension <xref target='RFC5878'/>, or in the certificate itself via an X.509v3 certificate extension <xref target='RFC5280'/>.
</t>
<t>
In order to ensure the correct behaviour of logs, logs also provide a global audit proof over the entire log. Any misbehaviour of logs can be detected through cross-checks on the global audit proof.
</t>
<t>
Logs are only expected to certify that they have seen a certificate and thus, we do not specify any revocation mechanism for audit proofs in this document. Logs will be append-only, and signatures will be valid indefinitely. 
</t>
</section>
    <section title="Cryptographic components">
      <section title="Merkle Hash Trees">
	<t>
	  Logs use a binary Merkle hash tree for efficient audit proofs. The hashing algorithm is SHA-256. The input to the Merkle tree hash is a list of data entries; these entries will be hashed to form the leaves of the Merkle hash tree. The output is a single 32-byte root hash. Given an ordered list of n inputs, D[0:n] = {d(0), d(1), ..., d(n-1)}, the Merkle Tree Hash (MTH) is thus defined as follows:
	</t>
	<t>
	  The hash of an empty list is the hash of an empty string:
	  <vspace blankLines='1' />
	  MTH({}) = SHA-256().
	  <vspace blankLines='1' />
	  The hash of a list with one entry is:
	  <vspace blankLines='1' />
	  MTH({d(0)}) = SHA-256(0 || d(0)).
	  <vspace blankLines='1' />
	  For n &gt; 1, let k be the largest power of two smaller than n. The Merkle Tree Hash of an n-element list D[0:n] is then defined recursively as
	  <vspace blankLines='1' />
	  MTH(D[0:n]) = SHA-256(1 || MTH(D[0:k]) || MTH(D[k:n])),
	  <vspace blankLines='1' />
	  where || is concatenation and D[k1:k2] denotes the length (k2 - k1) list {d(k1), d(k1+1),..., d(k2-1)}.
	</t>
<t>
Note that we do not require the length of the input list to be a power of two. The resulting Merkle tree may thus not be balanced, however, its shape is uniquely determined by the number of leaves. <spanx style="emph">This Merkle tree is essentially the same as the</spanx> <eref target='http://tamperevident.cs.rice.edu/Logging.html/'>history tree</eref> <spanx style="emph">proposal except our current definition omits dummy leaves.</spanx>
</t>
      <section title="Merkle audit paths" anchor='merkle_paths'>
	<t>
	  A Merkle audit path for a leaf in a Merkle hash tree is the list of all additional nodes in the Merkle tree required to compute the Merkle Tree Hash for that tree. If the root computed from the audit path matches the true root, then the audit path is proof that the leaf exists in the tree.
	</t>
	<t> Given an ordered list of n inputs to the tree, D[0:n] = {d(0), ..., d(n-1)}, the Merkle audit path PATH(m, D[0:n]) for the (m+1)th input d(m), 0 &lt;= m &lt; n, is defined as follows:
	</t>
	<t>
	  The path for the single leaf in a tree with a one-element input list D[0:1] = {d(0)} is empty:
	  <vspace blankLines='1' />
	  PATH(0, {d(0)}) = {}
	  <vspace blankLines='1' />
	  For n &gt; 1, let k be the largest power of two smaller than n. The path for the (m+1)th element d(m) in a list of n &gt m elements is then defined recursively as
	  <vspace blankLines='1' />
	  PATH(m, D[0:n]) = PATH(m, D[0:k]) : MTH(D[k:n]) for m &lt; k; and
	  <vspace blankLines='1' />
	  PATH(m, D[0:n]) = PATH(m - k, D[k:n]) : MTH(D[0:k]) for k &lt;= m &lt; n,
	  <vspace blankLines='1' />
	  where : is concatenation of lists and D[k1:k2] denotes the length (k2 - k1) list {d(k1), d(k1+1),..., d(k2-1)} as before.
	</t>
      </section>

      <section title="Merkle consistency proofs" anchor='consistency'>
	<t>
	  Merkle consistency proofs prove the append-only property of the tree. A Merkle consistency proof for a Merkle Tree Hash MTH(D[0:n]) and a previously advertised hash MTH(D[0:m]) of the first m leaves, m &lt;= n, is the list of nodes in the Merkle tree required to verify that the first m inputs D[0:m] are equal in both trees. Thus, a consistency proof must contain a set of intermediate nodes (i.e., commitments to inputs) sufficient to verify MTH(D[0:n]), such that (a subset of) the same nodes can be used to verify MTH(D[0:m]). We define an algorithm that outputs the (unique) minimal consistency proof. 
	</t>
	<t> Given an ordered list of n inputs to the tree, D[0:n] = {d(0), ..., d(n-1)}, the Merkle consistency proof PROOF(m, D[0:n]) for a previous root hash MTH(D[0:m]), 0 &lt; m &lt; n, is defined as PROOF(m, D[0:n]) = SUBPROOF(m, D[0:n], true):
	</t>
	<t>
	  The subproof for m = n is empty if m is the value for which PROOF was originally requested (meaning that the subtree root hash MTH(D[0:m]) is known):
	  <vspace blankLines='1' />
	  SUBPROOF(m, D[0:m], true) = {}
	  <vspace blankLines='1' />
 	  The subproof for m = n is the root hash committing inputs D[0:m] otherwise:
	  <vspace blankLines='1' />
	  SUBPROOF(m, D[0:m], false) = {MTH(D[0:m])}
	  <vspace blankLines='1' />    
	  For m &lt n, let k be the largest power of two smaller than n. The subproof is then defined recursively.
	  <vspace blankLines='1' />
If m &lt;= k, the right subtree entries D[k:n] only exist in the current tree. We prove that the left subtree entries D[0:k] are consistent and add a commitment to D[k:n]:
	  <vspace blankLines='1' />
	  SUBPROOF(m, D[0:n], b) = SUBPROOF(m, D[0:k], b) : MTH(D[k:n]).
	  <vspace blankLines='1' />
If m > k, the left subtree entries D[0:k] are identical in both trees. We prove that the right subtree entries D[k:n] are consistent and add a commitment to D[0:k].
	  <vspace blankLines='1' />
	  SUBPROOF(m, D[0:n], b) = SUBPROOF(m - k, D[k:n], false) : MTH(D[0:k]).
	  <vspace blankLines='1' />
	  Here : is concatenation of lists and D[k1:k2] denotes the length (k2 - k1) list {d(k1), d(k1+1),..., d(k2-1)} as before.
	</t>
	<t>
	  The number of nodes in the resulting proof is bounded above by ceil(log2(n)) + 1.
	</t>
      </section>

	<section title="Example">
	  <t>
	    The binary Merkle tree with 7 leaves:
<figure>
<artwork>    
            hash
           /    \
          /      \
         /        \
        /          \
       /            \
      k              l
     / \            / \
    /   \          /   \ 
   /     \        /     \    
  g       h      i      j
 / \     / \    / \     |
 a b     c d    e f     d6       
 | |     | |    | |                               
d0 d1   d2 d3  d4 d5    
</artwork>
</figure>
	  </t>
	  <t>
	    The audit path for d0 is [b, h, l].
	  </t>
	  <t>
	    The audit path for d3 is [c, g, l].
	  </t>
	  <t>
	    The audit path for d4 is [f, j, k].
	  </t>
	  <t>
	    The audit path for d6 is [i, k].
	  </t>
	  <t>
	    The same tree, built incrementally in four steps:
<figure>
<artwork>    
    hash0          hash1=k 
    / \              /  \  
   /   \            /    \ 
  /     \          /      \ 
  g      c         g       h 
 / \     |        / \     / \ 
 a b     d2       a b     c d 
 | |              | |     | |                   
d0 d1            d0 d1   d2 d3

          hash2                    hash
          /  \                    /    \
         /    \                  /      \
        /      \                /        \
       /        \              /          \
      /          \            /            \
     k            i          k              l
    / \          / \        / \            / \
   /   \         e f       /   \          /   \
  /     \        | |      /     \        /     \    
 g       h      d4 d5    g       h      i      j
/ \     / \             / \     / \    / \     |
a b     c d             a b     c d    e f     d6       
| |     | |             | |     | |    | |                               
d0 d1   d2 d3           d0 d1   d2 d3  d4 d5    
</artwork>
</figure>
	  </t>
	  <t>
	    The consistency proof between hash0 and hash is PROOF(3, D[0:7]) = [c, d, g, l]. c, g are used to verify hash0, and d, l are additionally used to verify hash.
	  </t>
	  <t>
	    The consistency proof between hash1 and hash is PROOF(4, D[0:7]) = [l]. hash can be verified, using hash1=k and l.
	  </t>
	  <t>
	    The consistency proof between hash2 and hash is PROOF(6, D[0:7]) = [i, j, k]. k, i are used to verify hash1, and j is additionally used to verify hash.
	  </t>
	</section>
      </section>
    </section>
    <section title="Log Format">
      <t>
	Certificate owners will be expected to submit certificates to certificate logs for public auditing. A log is a single, ever-growing, append-only Merkle Tree of such certificates.
      </t>
      <t>
	After accepting a certificate submission, the log MUST immediately return a Signed Certificate Hash (SCH). The SCH is the log's promise to incorporate the certificate in the Merkle Tree within a fixed amount of time known as the Maximum Merge Delay (MMD). Servers MUST present an SCH from one or more logs to the client together with the certificate. Clients MUST reject certificates that do not have a valid Signed Certificate Hash. [ben: can anyone request these proofs? don't see why not]
      </t>
      <t>
	Periodically, the log appends all new entries to the Merkle Tree, and signs the root of the tree. Clients and auditors can thus verify that each certificate for which an SCH has been issued indeed appears in the log. The log MUST incorporate a certificate in its Merkle Tree within the period defined by Maximum Merge Delay after the issuance of the SCH.
      </t>
      <section title="Log Entries">
	<t>
	  Anyone can submit a certificate to the log. In order to attribute each logged certificate to its issuer, the log shall publish a list of acceptable root certificates (this list should be the union of root certificates trusted by major browser vendors). Each submitted certificate MUST be accompanied by all additional certificates required to verify the certificate chain up to an accepted root certificate. The self-signed root certificate itself MAY be omitted from this list. 
	</t>
        <t>
	  Alternatively, Certificate Authorities may submit a certificate to the log prior to issuance. [TODO(ekasper): describe this procedure.] The Signed Certificate Hash can then be directly embedded in the final certificate via an X.509v3 certificate extension <xref target='RFC5280'/>.
	</t>
	<t>
	  The log MUST verify that the submitted leaf certificate has a valid signature chain leading back to a trusted root CA certificate, using the chain of intermediate CA certificates provided by the submitter. The log MAY accept certificates that have expired, are not yet valid, have been revoked or are otherwise not fully valid according to X509 verification rules. However, the log MUST refuse to publish certificates without a valid chain to a known root CA. If a certificate is accepted and an SCH issued, the log MUST store the chain used for verification, and MUST present this chain for auditing upon request.
	</t>
	<t>
	  Each certificate entry in the log MUST include the following components:
	</t>
<figure>
  <artwork>
    enum { x509_entry(0), precert_entry(1), (65535) } LogEntryType;

    struct {
        LogEntryType type;
            select (type) {
            case x509_entry: X509ChainEntry;
            case precert_entry: PrecertChainEntry;
        } entry;
    } LogEntry;

    opaque ASN.1Cert&lt;1..2^24-1&gt;;

    struct {
        ASN.1Cert leaf_certificate;
        ASN.1Cert certificate_chain&lt;0..2^24-1&gt;;
    } X509ChainEntry;

    struct {
        ASN.1Cert tbs_certificate;
        ASN.1Cert precertificate_chain&lt;1..2^24-1&gt;;
    } PrecertChainEntry;
  </artwork>
</figure>
	<t>[benl: Should we consider a small number for the certificate_chain? Or perhaps note that a log can impose a limit?]
	</t>
	<t>
	  <spanx style="verb">leaf_certificate</spanx> is the end-entity certificate submitted for auditing.
	</t>
	<t>
	  <spanx style="verb">certificate_chain</spanx> is a chain of additional certificates required to verify the leaf certificate. The first certificate MUST certify the leaf certificate. Each following certificate MUST directly certify the one preceding it. The self-signed root certificate MAY be omitted from the chain.
	</t>
	<t>
	  Structure of the Signed Certificate Hash:
	</t>
<figure>
  <artwork>
    struct {
        uint64 timestamp;
        digitally-signed struct {
            uint64 timestamp;
            LogEntryType type;
            ASN.1Cert signed_certificate;
        };
    } SignedCertificateHash;
  </artwork>
</figure>
	<t>
	  The encoding of the digitally-signed element is defined in <xref target='RFC5246'/>.
	</t>
	<t>
	  <spanx style="verb">timestamp</spanx> is the current UTC time [ekasper: since January 1, 1970, in milliseconds?]
	</t>
	<t>
	  <spanx style="verb">signed_certificate</spanx> is the <spanx style="verb">leaf_certificate</spanx> (in case of an X509ChainEntry), or <spanx style="verb">tbs_certificate</spanx> (in case of a PrecertChainEntry).
	</t>
      </section>

      <section title="Merkle Tree">
	<t> A certificate log MUST periodically append all new log entries to the log Merkle Tree. The log MUST sign these entries by constructing a binary Merkle Tree with log entries as consecutive inputs to the tree, signing the corresponding Merkle Tree Hash, and publishing each update to the tree in a Signed Merkle Tree Update. The hashing algorithm for the Merkle Tree Hash is SHA-256.
	</t>
	<t>
	  Structure of the Merkle Tree input:
	</t>
<figure>
  <artwork>
    struct {
        uint64 sch_timestamp;
        LogEntryType type;
        ASN.1Cert signed_certificate;
    } MerkleTreeLeaf;
  </artwork>
</figure>
	<t>
	  Structure of the Signed Merkle Tree Update:
	</t>
<figure>
  <artwork>
    struct {
        uint64 old_tree_size;
        uint64 timestamp;
        MerkleTreeLeaf new_leaves&lt;0..2^64-1&gt;;
        digitally-signed struct {
            uint64 timestamp;
            uint64 tree_size;
            opaque sha256_root_hash[32];
        } SignedTreeHead;
    } SignedMerkleTreeUpdate;
  </artwork>
</figure>
<t>[ekasper: I didn't like the idea of adding dummy entries so I changed this back to including the current timestamp, rather than the most recent sch timestamp. Ben, I seem to recall this was somehow inconvenient, but I forget why?]
</t>
	<t>
	  <spanx style="verb">old_tree_size</spanx>  is the size of the tree prior to this update.
	</t>
	<t>
	  <spanx style="verb">timestamp</spanx> is the current time. The timestamp MUST be at least as recent as the most recent SCH timestamp in the tree. Each subsequent timestamp MUST be more recent than the timestamp of the previous update. [ekasper: requiring unique timestamps allows us to have a unique answer to the question "What does the log contain at time t?". Any practical complications here?]
	</t>
	<t>
	  <spanx style="verb">tree_size</spanx> equals the number of entries in the new tree.
	</t>
	<t>
	  <spanx style="verb">new_leaves</spanx> is the list of leaves added to the tree in this update, ordered by leaf index. This order can be fixed arbitrarily amongst new entries.
	</t>
	<t>
	  <spanx style="verb">sha256_root_hash</spanx> is the root of the Merkle Hash Tree.
	</t>
	<t>The log MUST produce a Signed Merkle Tree Update at least as often as the Maximum Merge Delay. In the unlikely event that it receives no new submissions during an MMD period, the log SHALL sign the same Merkle Tree Hash with a fresh timestamp.
	</t>
      </section>
      <section title="Audit Proofs">
	<t> It is possible to audit the entire log by computing the current <spanx style="verb">sha256_root_hash</spanx> value from consecutive Signed Merkle Tree Updates, and verifying the Tree Head Signature. We rely on cross-checks of the Signed Tree Head between auditors to verify that their views of the log are consistent.
	</t>
	<t>
	  Additionally, logs provide Merkle audit proofs for efficient partial checks. (In fact, anyone can compute audit proofs from the full log.)
	</t>
	<t>
	  Structure of the Merkle audit proof:
	</t>
<figure>
  <artwork>
    struct {
        opaque sha256_hash[32];
    } MerkleNode;
  </artwork>
</figure>
<figure>
  <artwork>
    struct {
        uint64 tree_size;
        uint64 timestamp;
        uint64 leaf_index;
        MerkleNode audit_path&lt;0..2^16-1&gt;;
        TreeHeadSignature signature;
    } MerkleAuditProof;
  </artwork>
</figure>
	<t>
	  <spanx style="verb">tree_size</spanx> is the generation of the tree that this proof is for.
	</t>
	<t>
	  <spanx style="verb">timestamp</spanx> is the corresponding timestamp.
	</t>
	<t>
	  <spanx style="verb">leaf_index</spanx> is the index of the audited node in the Merkle tree, from 0 to <spanx style="verb">tree_size - 1</spanx>.
	</t>
	<t>
	  <spanx style="verb">audit_path</spanx> is a list of additional nodes in the Merkle tree required for reconstructing the root hash corresponding to the <spanx style="verb">tree_size</spanx>. Nodes must be listed from leaf to root level, i.e., in the order they are used in the Merkle Tree Hash computation, as defined in <xref target='merkle_paths' />. <spanx style="emph">Notice that the left-right ordering is determined by the position of the leaf.</spanx> The leaf node under audit as well as the root node shall be omitted from the path.
	</t>
	<t>
	  <spanx style="verb">tree_signature</spanx> is the signature on the tree for generation <spanx style="verb">tree_size</spanx>.
	</t>
	<t>
          A valid audit proof for a Merkle Tree Leaf MUST satisfy the following:
	</t>
	<t>
	  <list style='symbols'>
	    <t>
	      The <spanx style="verb">tree_size</spanx> MUST be at least 1;
	    </t>
	    <t>
	      The <spanx style="verb">leaf_index</spanx> MUST NOT exceed <spanx style="verb">tree_size - 1</spanx>;
	    </t>
	    <t>
	      The <spanx style="verb">tree_signature</spanx> MUST be a valid signature on the corresponding <spanx style="verb">timestamp</spanx>, <spanx style="verb">tree_size</spanx>, and the root hash reconstructed from the Merkle Tree Leaf, <spanx style="verb">leaf_index</spanx> and <spanx style="verb">audit_path</spanx>.
	    </t>
	  </list>
	</t>
      </section>
    </section>
    <section title="Efficiency Considerations">
      <t>
	The Merkle tree design serves the purpose of keeping communication overhead low.
      </t>
      <t>
	Auditing the log for integrity does not require third parties to maintain a copy of the entire log. The Signed Tree Head root hash can be updated incrementally as new entries become available, without recomputing the entire tree. Third party auditors need only store a logarithmic number of intermediate nodes in the Merkle Tree.
      </t>
      <t>
	Additionally, the Merkle consistency proofs defined in <xref target='consistency' /> can be used to efficiently prove the append-only property of an incremental update to the Merkle Tree, without auditing the entire tree.
      </t>
    </section>
  </middle>
  <back>
    <references>
      <reference anchor='RFC5246'>

	<front>
	  <title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
	  <author initials='T.' surname='Dierks' fullname='T. Dierks'>
	    <organization /></author>
	  <author initials='E.' surname='Rescorla' fullname='E. Rescorla'>
	    <organization /></author>
	  <date year='2008' month='August' />
	</front>

	<seriesInfo name='RFC' value='5246' />
      </reference>

      <reference anchor='RFC5878'>

	<front>
	  <title>The Transport Layer Security (TLS) Authorization Extensions</title>
	  <author initials='M.' surname='Brown' fullname='M. Brown'>
	    <organization >RedPhone Security</organization></author>
	  <author initials='R.' surname='Housley' fullname='R. Housley'>
	    <organization>Vigil Security</organization></author>
	  <date year='2010' month='May' />
	</front>

	<seriesInfo name='RFC' value='5280' />
      </reference>

      <reference anchor='RFC5280'>

	<front>
	  <title>Internet X.509 Public Key Infrastructure Certificate
	    and Certificate Revocation List (CRL) Profile</title>
	  <author initials='D.' surname='Cooper' fullname='D. Cooper'>
	    <organization>NIST</organization></author>
	  <author initials='S.' surname='Santesson' fullname='S. Santesson'>
	    <organization>Microsoft</organization></author>
	  <author initials='S.' surname='Farrell' fullname='S. Farrell'>
	    <organization>Trinity College Dublin</organization></author>
	  <author initials='S.' surname='Boeyen' fullname='S. Boeyen'>
	    <organization>Entrust</organization></author>
	  <author initials='R.' surname='Housley' fullname='R. Housley'>
	    <organization>Vigil Security</organization></author>
	  <author initials='W.' surname='Polk' fullname='W. Polk'>
	    <organization>NIST</organization></author>
	  <date year='2008' month='May' />
	</front>

	<seriesInfo name='RFC' value='5280' />
      </reference>
    </references>
  </back>
</rfc>
